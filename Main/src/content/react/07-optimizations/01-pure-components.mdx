---
title : Pure Components
published : true
---


### ğŸ”¹ What does â€œPureâ€ mean in React?

A **pure component** is just like a **pure function** in programming:

* A pure function always gives the **same output for the same input**.
* It doesnâ€™t rely on anything **outside its inputs** (no randomness, no hidden variables, no time).
* It doesnâ€™t cause **side effects** (like modifying global state, writing logs, etc.).

ğŸ‘‰ In React terms:

* A pure componentâ€™s output (the JSX it renders) depends **only** on its `props` and `state`.
* If `props` and `state` havenâ€™t changed, React can skip re-rendering it.

---

## ğŸ”¹ What does â€œImpureâ€ mean in React?

An **impure component** is the opposite:

* It may produce **different output for the same props/state**.
* It depends on **external factors**: random numbers, current time, global variables, API calls in render.
* It might cause side effects during render (e.g. mutating data outside the component).

---

## ğŸ”¹ Why do we need `React.memo`?

Even if you write your component as â€œpureâ€, React will **still re-render it whenever the parent re-renders**.

That means React doesnâ€™t automatically skip renders just because props didnâ€™t change.

ğŸ‘‰ `React.memo` is a wrapper that tells React:

> â€œThis component is pure. If the props havenâ€™t changed, donâ€™t re-render it.â€

So, `React.memo` makes a functional component **behave like a true pure component**, improving performance.

---

## ğŸ”¹ Example: Without `React.memo`

```jsx
function Greeting({ name }) {
  console.log("Rendering Greeting...");
  return <h1>Hello, {name}!</h1>;
}

export default function App() {
  const [count, setCount] = React.useState(0);

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Increase: {count}</button>
      <Greeting name="Hamza" />
    </div>
  );
}
```

ğŸ‘‰ Here, even though `name="Hamza"` never changes,
`<Greeting />` **re-renders every time** the button is clicked, because the parent `<App />` re-renders.

Thatâ€™s wasteful (not efficient), even though the component itself is conceptually pure.

---

## ğŸ”¹ Example: With `React.memo`

```jsx
const Greeting = React.memo(function Greeting({ name }) {
  console.log("Rendering Greeting...");
  return <h1>Hello, {name}!</h1>;
});

export default function App() {
  const [count, setCount] = React.useState(0);

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Increase: {count}</button>
      <Greeting name="Hamza" />
    </div>
  );
}
```

ğŸ‘‰ Now, when you click the button:

* The counter updates.
* The parent `<App />` re-renders.
* But React **skips re-rendering `<Greeting />`**, because its `props` (`name`) didnâ€™t change.

This makes `<Greeting />` a **true pure component**.

---

## ğŸ”¹ Summary

### âœ… Pure Component

* Output depends only on **props + state**.
* Same input â†’ same output.
* No side effects in render.
* With `React.memo` (for functions) or `React.PureComponent` (for classes), React can skip re-renders when props donâ€™t change.

### âŒ Impure Component

* Output may change even if props/state are the same (e.g. `Math.random()`, `Date.now()`, global variables).
* Has hidden dependencies or side effects in render.
* Always re-renders.

âœ¨ **Rule of thumb**: Write components as pure whenever possible. Use `React.memo` when you want to prevent unnecessary re-renders and optimize performance.
