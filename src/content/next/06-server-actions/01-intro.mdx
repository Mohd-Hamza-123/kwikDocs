---
title : "Server Actions"
published : true
---

#### Introduction to Next.js Server Actions

* What Server Actions are
* When and why to use them
* How they work (high-level)
* Example patterns (form submission, DB mutation)
* Best practices and caveats
* Suggested folder layout for your project


### 1. What are Server Actions?

Server Actions are functions that run on the **server** but can be invoked directly from client components or server components in Next.js (App Router). They let you perform server-side work (database writes, file uploads, calls to internal APIs) without having to create a separate API route or `fetch` call.

They provide a simple, secure, and ergonomic way to handle mutations and side effects in a Next.js app.


### 2. Why use Server Actions?

* **Less boilerplate:** No need for a dedicated `/api` endpoint + client `fetch` to call it.
* **Automatic security boundary:** Runs on the server, so secrets and DB credentials stay server-only.
* **Simpler data flow:** Call a function directly from a client-side form/button.
* **Better dev ergonomics:** Fewer moving parts to test and maintain.

Use them for: form submissions, saving user settings, server-side validation, sending emails, initiating background jobs, or any server-only side effect.


### 3. How they work (high-level)

* You define a function and mark it with `use server` so that Next.js knows it should be executed on the server.
* That function can access server resources (DB, filesystem, environment variables).
* The client calls the function; Next.js handles calling it on the server and serializing results/errors back to the client.

Key idea: **the call looks local but executes remotely.**


Below are minimal examples (pseudocode-style). Adapt to your stack and runtime.

#### 4.1 Simple server action for form submit

```jsx
// app/(dashboard)/settings/page.jsx (client component)
'use client'
import { useState } from 'react'
import saveSettings from './actions/saveSettings'

export default function SettingsForm({ initial }) {
  const [name, setName] = useState(initial.name)
  return (
    <form action={async (formData) => await saveSettings(formData)}>
      <input name="name" value={name} onChange={e => setName(e.target.value)} />
      <button type="submit">Save</button>
    </form>
  )
}
```

```js
// app/(dashboard)/settings/actions/saveSettings.js (server action)
'use server'
export default async function saveSettings(formData) {
  const name = formData.get('name')
  // validate
  if (!name) throw new Error('Name required')
  // write to DB (server-only)
  await db.user.update({ where: { id: 1 }, data: { name } })
  return { ok: true }
}
```

#### 4.2 Calling action from client code (non-form)

```jsx
'use client'
import updateLike from './actions/updateLike'

export default function LikeButton({ postId }) {
  return (
    <button onClick={() => updateLike(postId)}>Like</button>
  )
}
```

---

### 5. Best practices

* **Keep actions focused:** Single responsibility (e.g., `createPost`, `uploadAvatar`).
* **Validation:** Validate inputs server-side — client-side checks are convenience only.
* **Error handling:** Return structured errors and handle them on the client.
* **Idempotency:** For potentially repeated requests (retries), design actions to be safe or detect duplicates.
* **Avoid heavy blocking work:** Offload long-running tasks to background workers if possible.
* **Security:** Never leak secrets to client code; use Server Actions to keep secrets safe.


### 6. limitations

* **Bundling and size:** Server actions can increase server bundle size; keep them small and split where needed.
* **Not always ideal for streaming responses** or very fine-grained real-time interactions — evaluate use-case.
* **Platform/runtime differences:** Some hosting providers may have constraints; test on your target platform.

---

