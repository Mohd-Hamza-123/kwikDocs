---
title : Updating Document
published : true
---


### 1) Firebase configuration

Put this in a `firebase.js` (or `firebaseConfig.js`) and import `db` where needed.

```js
// firebase.js
import { initializeApp } from "firebase/app";
import { getFirestore } from "firebase/firestore";

const firebaseConfig = {
  apiKey: "...",
  authDomain: "...",
  projectId: "...",
  // ...
};

const app = initializeApp(firebaseConfig);
export const db = getFirestore(app);
```


### 2) Update by Document ID

`updateDoc` updates only the fields you provide â€” it **won't** overwrite the whole document.

```jsx
// UpdateDocExample.jsx
import React from "react";
import { doc, updateDoc, serverTimestamp } from "firebase/firestore";
import { db } from "./firebase";

export default function UpdateDocExample({ docId }) {
  const handleUpdate = async () => {
    try {
      const docRef = doc(db, "users", docId); // collection "users", document id
      await updateDoc(docRef, {
        displayName: "Hamza",
        lastUpdated: serverTimestamp(),
      });
      alert("Updated successfully");
    } catch (err) {
      console.error("Update failed:", err);
      alert("Update failed: " + err.message);
    }
  };

  return <button onClick={handleUpdate}>Update user</button>;
}
```


### 3) Overwrite vs merge (`setDoc`)

If you want to overwrite the whole document use `setDoc(docRef, data)`. To merge with existing fields, use `{ merge: true }`.

```jsx
import { doc, setDoc } from "firebase/firestore";

await setDoc(doc(db, "users", docId), {
  displayName: "New Name",
  role: "editor"
}, { merge: true }); // merges, doesn't delete other fields
```


### 4) Update nested fields

Use dot notation to update nested fields:

```js
await updateDoc(doc(db, "users", docId), {
  "preferences.theme": "dark",
  "profile.age": 30
});
```


### 5) Array operations, increment, delete field

Useful atomic operations:

```js
import { arrayUnion, arrayRemove, increment, deleteField } from "firebase/firestore";

await updateDoc(doc(db, "posts", postId), {
  tags: arrayUnion("react"),       // add to array (no dup)
  viewersCount: increment(1),     // increment numeric field
  comments: arrayRemove({ id: 123 }), // remove matching element (value equality)
  obsoleteField: deleteField()    // removes the field from document
});
```


### 6) Transaction (atomic read-modify-write)

If you need to read a value, compute, and update atomically:

```jsx
import { doc, runTransaction } from "firebase/firestore";

async function incrementScore(docId, delta = 1) {
  const docRef = doc(db, "games", docId);
  try {
    await runTransaction(db, async (t) => {
      const snap = await t.get(docRef);
      if (!snap.exists()) throw new Error("Document does not exist!");
      const current = snap.data().score || 0;
      t.update(docRef, { score: current + delta });
    });
    console.log("Transaction successful");
  } catch (e) {
    console.error("Transaction failed: ", e);
  }
}
```

### 6. Update document of a subcollection

```js
import { doc, updateDoc } from "firebase/firestore";
import { fireStoreDb } from "@/firebase/firebase";

const updateComment = async (postId, commentId) => {
  try {
    const newData = {
      text: "New comment text",
      isPublished : true
    }

    const commentRef = doc(fireStoreDb, "posts", postId, "comments", commentId);
    await updateDoc(commentRef, newData);
    console.log("Comment updated!");
  } catch (error) {
    console.error("Error updating comment:", error);
  }
};
```

---


