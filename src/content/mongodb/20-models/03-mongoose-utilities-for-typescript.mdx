---
title: Mongoose Schema Design with TypeScript
isPublished: true
---

When working with Mongoose in a TypeScript project, we can use additional utilities that make our schemas and models **type-safe** and **fully validated in code**.

Common import:

```ts
import { Schema, model, models, InferSchemaType, HydratedDocument, Types } from "mongoose";
````

This guide explains the **TypeScript utilities from Mongoose**:

* `InferSchemaType`
* `HydratedDocument`
* `Types` (complete breakdown)

> ğŸ“Œ Make sure you understand `Schema`, `model`, and `models` from the previous document.

---

### ğŸ§  InferSchemaType

`InferSchemaType` automatically generates a **TypeScript type** from a Mongoose Schema.

âœ” No duplicate typing
âœ” Always in sync with the schema
âœ” Safer refactoring (change schema â TS updates automatically)

#### ğŸ§ª Example

```ts
const userSchema = new Schema({
  name: { type: String, required: true },
  age: Number,
});

export type User = InferSchemaType<typeof userSchema>;
```

Implicit result:

```ts
{
  name: string;
  age?: number;
}
```

ğŸ“Œ **No manual typing needed â€” TypeScript infers it.**

---

### ğŸ“„ HydratedDocument

`HydratedDocument` represents a **real document returned by Mongoose**, not just plain data.
It includes:

* `_id`
* `.save()`
* `.populate()`
* default values
* virtuals
* getters/setters
* middleware side effects

> ğŸ“Œ Use it when you work with *fetched* or *created* documents.

#### ğŸ§ª Example

```ts
export type UserDocument = HydratedDocument<User>;
```

Usage:

```ts
const user = await UserModel.findById(id);
// user is typed as UserDocument

user.save();     // âœ” typed
user._id;        // âœ” typed
user.populate(); // âœ” typed
```

Without it:

```ts
user.save();   // âŒ TS error
user._id;      // âŒ unknown type
```

ğŸ“Œ **Use HydratedDocument for CRUD operations.**

---

### ğŸ†” Types (Complete Breakdown)

`Types` is a **namespace** in Mongoose that provides special MongoDB-based types.
These are not normal JavaScript types.

You can import it like:

```ts
import { Types } from "mongoose";
```

#### ğŸ” Why use `Types`?

MongoDB uses specialized types internally.
For example, **ObjectId â‰  string**, and **Decimal128 â‰  number**.
`Types` helps TypeScript understand the difference.

---

### ğŸ”£ Major Types Provided by Mongoose

| Type               | Use Case                             | Example                          |
| ------------------ | ------------------------------------ | -------------------------------- |
| `Types.ObjectId`   | Unique MongoDB IDs & references      | `type UserId = Types.ObjectId`   |
| `Types.Decimal128` | High-precision numbers (money, cash) | `price: Types.Decimal128`        |
| `Types.Map`        | Dynamic key/value objects            | `settings: Map<string, boolean>` |
| `Types.Buffer`     | Binary data (files, images)          | `profilePic: Buffer`             |
| `Types.Array<T>`   | Strongly typed arrays                | `tags: Types.Array<string>`      |
| `Types.Date`       | Explicit date typing                 | `createdAt: Types.Date`          |

---

### ğŸ§ª Examples for Each

#### 1) `Types.ObjectId`

```ts
type UserId = Types.ObjectId;

const postSchema = new Schema({
  author: { type: Types.ObjectId, ref: "User" }
});
```

#### 2) `Types.Decimal128` (Best for money/financial fields)

```ts
const productSchema = new Schema({
  price: Types.Decimal128
});
```

#### 3) `Types.Map`

```ts
const userSchema = new Schema({
  preferences: {
    type: Map,
    of: Boolean
  }
});
```

#### 4) `Types.Buffer`

```ts
const fileSchema = new Schema({
  data: Buffer,
  contentType: String
});
```

#### 5) `Types.Array`

```ts
const blogSchema = new Schema({
  tags: [String] // or Types.Array<string> in TS
});
```

ğŸ“Œ `Types.Array<T>` enforces the type inside the array.

---




