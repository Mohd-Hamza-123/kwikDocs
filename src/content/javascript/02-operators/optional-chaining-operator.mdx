---
title: Optional Chaining Operator
published: true
---


The optional chaining operator `?.` allows you to **safely access deeply nested object properties** without having to check if each level exists.
If any part before `?.` is `null` or `undefined`, the expression returns `undefined` **instead of throwing an error**.

---

### ✅ Syntax:

```js
object?.property
object?.[key]
object?.method?.()
```

---

### 🔸 Example 1: Accessing nested object property safely

```js
let user = {
  name: "Hamza",
  address: {
    city: "Delhi",
  }
};

let city = user.address?.city;
console.log(city); // Output: Delhi
```

📝 Since `address` exists, `city` is accessed safely.

---

### 🔸 Example 2: When a nested property doesn't exist

```js
let user = {
  name: "Hamza"
};

let city = user.address?.city;
console.log(city); // Output: undefined
```

📝 `user.address` is `undefined`, but no error is thrown — it just returns `undefined`.

---

### 🔸 Example 3: Optional chaining with method call

```js
let person = {
  greet: function () {
    return "Hello!";
  }
};

console.log(person.greet?.()); // Output: Hello!
console.log(person.sayBye?.()); // Output: undefined (no error)
```

---

### 🔸 Example 4: Optional chaining with array

```js
let data = {
  users: [
    { name: "Hamza" },
    { name: "Ali" }
  ]
};

console.log(data.users?.[0]?.name); // Output: Hamza
console.log(data.users?.[2]?.name); // Output: undefined
```

---

### ✅ Why Use It?

* Prevents runtime errors like: `Cannot read property 'x' of undefined`
* Cleans up long `&&` chains
* Great for dealing with APIs, optional data, or deeply nested structures

---

### ❗ Without Optional Chaining (old way)

```js
let city = user && user.address && user.address.city;
```

✅ With Optional Chaining:

```js
let city = user?.address?.city;
```

---

