---
title : Execution Context
published : true
---

When JavaScript runs your code, it does so within an **Execution Context**. There are **two main types**:

1. **Global Execution Context (GEC)**
2. **Function Execution Context (FEC)**

Each context goes through two phases: **Memory Creation** and **Code Execution**.


### ğŸŒ 1. Global Execution Context (GEC)

This is the first execution context created when your script runs.

### ğŸ” Phase 1: Memory Creation

* JavaScript sets up memory for all global variables and functions.
* `var` variables â†’ hoisted and initialized to `undefined`.
* `let` and `const` â†’ hoisted but remain in the **TDZ** (Temporal Dead Zone) means they are not initialized. Accessing them will result in a `ReferenceError`.
* Function declarations â†’ hoisted entirely (function body is stored).
* `this` â†’ set to the global object (`window` in browsers).

### â–¶ï¸ Phase 2: Code Execution

* Code is executed line by line.
* Variables are assigned values.
* Functions are invoked.
* If a function is called, a new **Function Execution Context** is created and pushed onto the **call stack**.

---

## ğŸ§ª Example (Global Scope):

```js
console.log(x);     // undefined
// console.log(y);  // âŒ ReferenceError (TDZ)
var x = 10;
let y = 20;

function greet() {
  console.log("Hello from GEC!");
}

greet();
```

---

## ğŸ”„ 2. Function Execution Context (FEC)

A new **Function Execution Context** is created **every time a function is invoked**.

Each FEC also goes through:

### ğŸ” Phase 1: Memory Creation

* Arguments object is created.
* `var` variables â†’ hoisted to `undefined`.
* `let` and `const` â†’ hoisted but kept in TDZ. Means they are not initialized. Accessing them will result in a `ReferenceError`.
* Function declarations inside the function â†’ hoisted.
* `this` â†’ depends on how the function is called (global, object method, etc.).

### â–¶ï¸ Phase 2: Code Execution

* Local variables are assigned.
* Inner functions may be called.
* Once done, the context is popped off the call stack.

---

## ğŸ§ª Example (Function Scope):

```js
function testScope(a, b) {
  console.log(x);     // undefined
  // console.log(y);  // âŒ ReferenceError
  var x = a + b;
  let y = x * 2;

  function inner() {
    console.log("Inner function");
  }

  inner();
}

testScope(3, 4);
```

### ğŸ’¡ In `testScope`â€™s Execution Context:

* `a`, `b` â†’ assigned via arguments
* `x` â†’ hoisted as `undefined`, then assigned to `a + b` â†’ `7`
* `y` â†’ hoisted (TDZ), then assigned `x * 2` â†’ `14`
* `inner()` â†’ hoisted and called

---

## ğŸ§  Call Stack Overview

JavaScript uses a **call stack** to manage execution contexts:

1. Global Execution Context is pushed first.
2. When `greet()` or `testScope()` is called, a new FEC is pushed.
3. When a function finishes, its context is popped off.

```
Call Stack:
---------------------
| testScope()       |
| global()          |
---------------------
```

---

## ğŸ“Œ Summary Table

| Feature             | Global Execution Context         | Function Execution Context        |
| ------------------- | -------------------------------- | --------------------------------- |
| Created             | When script first runs           | When a function is invoked        |
| `this`              | Global object (`window`, etc.)   | Depends on how function is called |
| Arguments object    | âŒ Not available                  | âœ… Available                       |
| Hoisting behavior   | Applies to global vars/functions | Applies to local vars/functions   |
| Lives in Call Stack | Always at the bottom             | Pushed/popped as functions run    |

---
