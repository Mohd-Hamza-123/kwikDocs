---
title: Polymorphism
description: Polymorphism in OOPs
published: true
---

Polymorphism is a mechanism where a single function or method can be used to perform different actions depending on the type of the object it is called on. This promotes code reuse and flexibility.

#### Example 1)

```python
class Car:
    def FuelType(self):
        return 'Petrol'

class ElectricCar(Car):
    def FuelType(self):
        return 'Electric Charge'

car1 = Car()
print(car1.FuelType())
eCar1 = ElectricCar()
print(eCar1.FuelType())
```

#### Example 2)

```python
class Shape:
    def area(self):
        return 'Make a shape and calculate its area'

class Square(Shape):
    def __init__(self,sideLength):
        self.sideLength = sideLength

    def area(self):
        return f"Area = {self.sideLength ** 2}"
    
class Circle(Shape):
    def __init__(self,radius):
        self.radius = radius

    def area(self):
        return f"Area = {3.14 * (self.radius ** 2)}"


s1 = Square(5)
print(s1.area())
c1 = Circle(3)
print(c1.area())
```

### How to get total no of instances of a class? 

To keep track of how many instances of a class have been created, you can use a class-level attribute (shared by all instances of the class) to count the number of instances

```python
class Counter:
    instance_count = 0

    def __init__(self):
        Counter.instance_count += 1

# Example usage
obj1 = Counter()
obj2 = Counter()
obj3 = Counter()

print(f"Total instances created: {Counter.instance_count}")  # Output: 3

```

### Function Overloading

Function overloading allows you to define multiple functions with the same name but different parameters (number, type, or order) within the same scope, enabling the compiler to choose the appropriate function based on the arguments provided during the call. 

Python does not natively support function overloading. Instead, it uses flexible mechanisms like default arguments, `*args`, `**kwargs`, or dynamic type checking to achieve similar behavior.