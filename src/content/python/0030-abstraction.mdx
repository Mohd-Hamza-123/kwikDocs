---
title: Abstraction
description: Abstraction in OOPs
published: true
---

- Abstraction focuses on hiding complex implementation details and showing only the essential features of an object. 

- Abstraction helps simplify and restrict how the code is used.

#### Code without Abstraction

```python
class CreditCardPayment:
    def encrypt_card_data(self, data):
        # Complex encryption logic
        return f"encrypted({data})"
    
    def validate_card(self, card_number):
        # Complex validation logic
        return True
    
    def process_payment(self, amount):
        card_data = self.encrypt_card_data("Card Number")
        if self.validate_card(card_data):
            print(f"Processing payment of ${amount}")
```

Here, the developer can call any method (like encrypt_card_data() or validate_card()), even though they shouldn’t.

#### Code With Abstraction 

```python
class CreditCardPayment:
    def __encrypt_card_data(self, data):  # Private method
        # Complex encryption logic
        return f"encrypted({data})"
    
    def __validate_card(self, card_data):  # Private method
        # Complex validation logic
        return True
    
    def process_payment(self, amount):
        card_data = self.__encrypt_card_data("Card Number")
        if self.__validate_card(card_data):
            print(f"Processing payment of ${amount:.2f}")
```

- The methods __encrypt_card_data and __validate_card are now private (using __).
- The developer can only call process_payment. They can’t directly use __encrypt_card_data or __validate_card.
