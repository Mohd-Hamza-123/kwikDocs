---
title: useRef Hook
published: true
---


`useRef` is a React hook that lets you create a **mutable object** that persists across renders.

ğŸ‘‰ Think of it as a **box** you can store a value in:

* The value inside (`.current`) can be changed without causing the component to re-render.
* Itâ€™s often used to **reference DOM elements** (like focusing an input).
* It can also store **any mutable value** (like a counter, timeout ID, etc.).

---

### ğŸ”¹ Syntax

```jsx
import { useRef } from "react";

const myRef = useRef(initialValue);
```

* Returns an object: `{ current: initialValue }`.
* Unlike `useState`, changing `myRef.current` does **not trigger re-render**.

---

### ğŸ”¹ 1. Common Use: Accessing DOM elements

```jsx
import { useRef } from "react";

function App() {
  const inputRef = useRef(null);

  const focusInput = () => {
    inputRef.current.focus(); // Focuses the input element
  };

  return (
    <div>
      <input ref={inputRef} type="text" placeholder="Type here..." />
      <button onClick={focusInput}>Focus Input</button>
    </div>
  );
}
```

ğŸ”‘ Here:

* `ref={inputRef}` attaches the DOM element to `inputRef.current`.
* `inputRef.current` points to the actual `<input>` element.

---

### ğŸ”¹ 2. Storing values without re-render

```jsx
import { useRef, useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);
  const renderCount = useRef(0);

  renderCount.current += 1; // Updates every render, but no re-render happens

  return (
    <div>
      <p>Count: {count}</p>
      <p>Component rendered {renderCount.current} times</p>
      <button onClick={() => setCount(count + 1)}>Increase</button>
    </div>
  );
}
```

ğŸ”‘ Here:

* `renderCount.current` keeps track of renders, but updating it doesnâ€™t cause re-renders (unlike state).

---

## ğŸ”¹ 3. Keeping values between renders (like setTimeout IDs)

```jsx
import { useRef, useEffect } from "react";

function Timer() {
  const intervalRef = useRef(null);

  useEffect(() => {
    intervalRef.current = setInterval(() => {
      console.log("tick");
    }, 1000);

    return () => clearInterval(intervalRef.current); // cleanup
  }, []);

  return <h2>Timer running... check console</h2>;
}
```

---

### ğŸ”¹ When to use `useRef`

âœ… Good for:

* Accessing/manipulating DOM elements.
* Storing mutable values that donâ€™t need to trigger a re-render (like timers, previous values, etc.).
* Persisting values across renders without using state.

âŒ Donâ€™t use `useRef` when you need the UI to update â†’ use `useState` instead.

---

ğŸ‘‰ Simple rule:

* **Need re-render?** â†’ use `useState`.
* **Just need to store/read a value across renders?** â†’ use `useRef`.

---
