---
title : Derived State
published : true
---


**Derived state** means:
ğŸ‘‰ A piece of state in your component that can be **calculated (derived)** from existing `props` or `state`, instead of storing it separately.

* You donâ€™t need to store it in `useState`.
* Instead, compute it *on the fly* inside `render` (or in variables) whenever needed.

âš¡ Reactâ€™s rule of thumb:

> If you can calculate something from existing state/props, donâ€™t duplicate it as another state variable.

---

**ğŸ”¹ Example 1: Count and Double Value**

âŒ **Wrong way (extra state):**

```jsx
import React, { useState } from "react";

export default function Counter() {
  const [count, setCount] = useState(0);
  const [double, setDouble] = useState(0); // âŒ derived state

  function increment() {
    const newCount = count + 1;
    setCount(newCount);
    setDouble(newCount * 2); // keeping in sync manually
  }

  return (
    <div>
      <p>Count: {count}</p>
      <p>Double: {double}</p>
      <button onClick={increment}>+1</button>
    </div>
  );
}
```

ğŸ‘‰ Here, `double` is **derived** from `count`.
Weâ€™re duplicating state unnecessarily and must manually keep them in sync.

âœ… **Better way (derive inside render):**

```jsx
import React, { useState } from "react";

export default function Counter() {
  const [count, setCount] = useState(0);

  const double = count * 2; // derived value

  return (
    <div>
      <p>Count: {count}</p>
      <p>Double: {double}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </div>
  );
}
```

ğŸ‘‰ `double` is now derived from `count` â€” no need for extra state.

---

**ğŸ”¹ Example 2: Filtering a List**

âŒ **Wrong way (store filtered list in state):**

```jsx
function UserList({ users }) {
  const [search, setSearch] = useState("");
  const [filtered, setFiltered] = useState(users); // âŒ redundant

  function handleSearch(e) {
    const query = e.target.value;
    setSearch(query);
    setFiltered(users.filter((u) => u.includes(query))); // syncing manually
  }

  return (
    <div>
      <input value={search} onChange={handleSearch} />
      <ul>
        {filtered.map((u) => (
          <li key={u}>{u}</li>
        ))}
      </ul>
    </div>
  );
}
```

âœ… **Better way (derive filtered list dynamically):**

```jsx
function UserList({ users }) {
  const [search, setSearch] = useState("");

  const filtered = users.filter((u) =>
    u.toLowerCase().includes(search.toLowerCase())
  ); // derived state

  return (
    <div>
      <input value={search} onChange={(e) => setSearch(e.target.value)} />
      <ul>
        {filtered.map((u) => (
          <li key={u}>{u}</li>
        ))}
      </ul>
    </div>
  );
}
```

ğŸ‘‰ Now `filtered` is recalculated each render instead of being stored in state.

---

**ğŸ”¹ Example 3: Props â†’ Derived State**

âŒ **Wrong way:**

```jsx
function Welcome({ name }) {
  const [greeting, setGreeting] = useState(`Hello, ${name}`); // âŒ unnecessary

  return <h1>{greeting}</h1>;
}
```

âœ… **Better way:**

```jsx
function Welcome({ name }) {
  const greeting = `Hello, ${name}`; // derived from props
  return <h1>{greeting}</h1>;
}
```

---

### ğŸ”¹ When to Use Derived State?

âœ… Use **derived values (variables)** instead of extra state when:

* The value can be calculated from `props` or `state`.
* It doesnâ€™t need to be â€œrememberedâ€ across renders.

âš ï¸ But **sometimes you DO need state** if:

* The derived value is expensive to calculate (then use `useMemo`).
* You want to "capture" a value at a certain time instead of always recalculating.
* Example: storing **form input** or **server response**.

---

### ğŸ”¹ Summary

* **Derived state** = data you can compute from existing `props` or `state`.
* Avoid duplicating state â†’ it leads to bugs (data gets out of sync).
* Use **computed variables** (or `useMemo`) instead of extra `useState`.

ğŸ‘‰ Rule of thumb: **â€œIf you can derive it, donâ€™t store it.â€**


