---
title : Pure Components
published : true
---


### 🔹 What does “Pure” mean in React?

A **pure component** is just like a **pure function** in programming:

* A pure function always gives the **same output for the same input**.
* It doesn’t rely on anything **outside its inputs** (no randomness, no hidden variables, no time).
* It doesn’t cause **side effects** (like modifying global state, writing logs, etc.).

👉 In React terms:

* A pure component’s output (the JSX it renders) depends **only** on its `props` and `state`.
* If `props` and `state` haven’t changed, React can skip re-rendering it.

---

## 🔹 What does “Impure” mean in React?

An **impure component** is the opposite:

* It may produce **different output for the same props/state**.
* It depends on **external factors**: random numbers, current time, global variables, API calls in render.
* It might cause side effects during render (e.g. mutating data outside the component).

---

## 🔹 Why do we need `React.memo`?

Even if you write your component as “pure”, React will **still re-render it whenever the parent re-renders**.

That means React doesn’t automatically skip renders just because props didn’t change.

👉 `React.memo` is a wrapper that tells React:

> “This component is pure. If the props haven’t changed, don’t re-render it.”

So, `React.memo` makes a functional component **behave like a true pure component**, improving performance.

---

## 🔹 Example: Without `React.memo`

```jsx
function Greeting({ name }) {
  console.log("Rendering Greeting...");
  return <h1>Hello, {name}!</h1>;
}

export default function App() {
  const [count, setCount] = React.useState(0);

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Increase: {count}</button>
      <Greeting name="Hamza" />
    </div>
  );
}
```

👉 Here, even though `name="Hamza"` never changes,
`<Greeting />` **re-renders every time** the button is clicked, because the parent `<App />` re-renders.

That’s wasteful (not efficient), even though the component itself is conceptually pure.

---

## 🔹 Example: With `React.memo`

```jsx
const Greeting = React.memo(function Greeting({ name }) {
  console.log("Rendering Greeting...");
  return <h1>Hello, {name}!</h1>;
});

export default function App() {
  const [count, setCount] = React.useState(0);

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Increase: {count}</button>
      <Greeting name="Hamza" />
    </div>
  );
}
```

👉 Now, when you click the button:

* The counter updates.
* The parent `<App />` re-renders.
* But React **skips re-rendering `<Greeting />`**, because its `props` (`name`) didn’t change.

This makes `<Greeting />` a **true pure component**.

---

## 🔹 Summary

### ✅ Pure Component

* Output depends only on **props + state**.
* Same input → same output.
* No side effects in render.
* With `React.memo` (for functions) or `React.PureComponent` (for classes), React can skip re-renders when props don’t change.

### ❌ Impure Component

* Output may change even if props/state are the same (e.g. `Math.random()`, `Date.now()`, global variables).
* Has hidden dependencies or side effects in render.
* Always re-renders.

✨ **Rule of thumb**: Write components as pure whenever possible. Use `React.memo` when you want to prevent unnecessary re-renders and optimize performance.
